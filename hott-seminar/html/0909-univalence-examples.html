<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>0909-univalence-examples</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--without-K</a> <a id="25" class="Pragma">--rewriting</a> <a id="37" class="Symbol">#-}</a>
<a id="41" class="Keyword">module</a> <a id="48" href="0909-univalence-examples.html" class="Module">0909-univalence-examples</a> <a id="73" class="Keyword">where</a>
<a id="79" class="Keyword">open</a> <a id="84" class="Keyword">import</a> <a id="91" href="0909-prelude.html" class="Module">0909-prelude</a> <a id="104" class="Keyword">public</a>

<a id="¬tt≡ff"></a><a id="112" href="0909-univalence-examples.html#112" class="Function">¬tt≡ff</a> <a id="119" class="Symbol">:</a> <a id="121" href="0811-inductive-types.html#772" class="Function">¬</a> <a id="123" class="Symbol">(</a><a id="124" href="0811-inductive-types.html#840" class="InductiveConstructor">tt</a> <a id="127" href="0811-inductive-types.html#983" class="Datatype Operator">≡</a> <a id="129" href="0811-inductive-types.html#843" class="InductiveConstructor">ff</a><a id="131" class="Symbol">)</a>
<a id="133" href="0909-univalence-examples.html#112" class="Function">¬tt≡ff</a> <a id="140" class="Symbol">()</a>

<a id="flip"></a><a id="144" href="0909-univalence-examples.html#144" class="Function">flip</a> <a id="149" class="Symbol">:</a> <a id="151" href="0811-inductive-types.html#820" class="Datatype">Bool</a> <a id="156" class="Symbol">→</a> <a id="158" href="0811-inductive-types.html#820" class="Datatype">Bool</a>
<a id="163" href="0909-univalence-examples.html#144" class="Function">flip</a> <a id="168" href="0811-inductive-types.html#840" class="InductiveConstructor">tt</a> <a id="171" class="Symbol">=</a> <a id="173" href="0811-inductive-types.html#843" class="InductiveConstructor">ff</a>
<a id="176" href="0909-univalence-examples.html#144" class="Function">flip</a> <a id="181" href="0811-inductive-types.html#843" class="InductiveConstructor">ff</a> <a id="184" class="Symbol">=</a> <a id="186" href="0811-inductive-types.html#840" class="InductiveConstructor">tt</a>

<a id="flip-invol"></a><a id="190" href="0909-univalence-examples.html#190" class="Function">flip-invol</a> <a id="201" class="Symbol">:</a> <a id="203" href="0909-univalence-examples.html#144" class="Function">flip</a> <a id="208" href="0909-prelude.html#414" class="Function Operator">∘</a> <a id="210" href="0909-univalence-examples.html#144" class="Function">flip</a> <a id="215" href="0909-prelude.html#1493" class="Function Operator">∼</a> <a id="217" href="0909-prelude.html#384" class="Function">id</a>
<a id="220" href="0909-univalence-examples.html#190" class="Function">flip-invol</a> <a id="231" href="0811-inductive-types.html#840" class="InductiveConstructor">tt</a> <a id="234" class="Symbol">=</a> <a id="236" href="0811-inductive-types.html#1029" class="InductiveConstructor">refl</a>
<a id="241" href="0909-univalence-examples.html#190" class="Function">flip-invol</a> <a id="252" href="0811-inductive-types.html#843" class="InductiveConstructor">ff</a> <a id="255" class="Symbol">=</a> <a id="257" href="0811-inductive-types.html#1029" class="InductiveConstructor">refl</a>

<a id="flip-eqv"></a><a id="263" href="0909-univalence-examples.html#263" class="Function">flip-eqv</a> <a id="272" class="Symbol">:</a> <a id="274" href="0909-prelude.html#1988" class="Record">is-equiv</a> <a id="283" href="0909-univalence-examples.html#144" class="Function">flip</a>
<a id="288" href="0909-univalence-examples.html#263" class="Function">flip-eqv</a> <a id="297" class="Symbol">=</a> <a id="299" href="0909-prelude.html#2083" class="InductiveConstructor">Inverse</a> <a id="307" href="0909-univalence-examples.html#144" class="Function">flip</a> <a id="312" href="0909-univalence-examples.html#190" class="Function">flip-invol</a> <a id="323" href="0909-univalence-examples.html#144" class="Function">flip</a> <a id="328" href="0909-univalence-examples.html#190" class="Function">flip-invol</a>

<a id="flippath"></a><a id="340" href="0909-univalence-examples.html#340" class="Function">flippath</a> <a id="349" class="Symbol">:</a> <a id="351" href="0811-inductive-types.html#820" class="Datatype">Bool</a> <a id="356" href="0811-inductive-types.html#983" class="Datatype Operator">≡</a> <a id="358" href="0811-inductive-types.html#820" class="Datatype">Bool</a>
<a id="363" href="0909-univalence-examples.html#340" class="Function">flippath</a> <a id="372" class="Symbol">=</a> <a id="374" href="0909-prelude.html#2904" class="Function">ua</a> <a id="377" class="Symbol">(</a><a id="378" href="0909-prelude.html#2285" class="InductiveConstructor">Equiv</a> <a id="384" href="0909-univalence-examples.html#144" class="Function">flip</a> <a id="389" href="0909-univalence-examples.html#263" class="Function">flip-eqv</a><a id="397" class="Symbol">)</a>

<a id="400" class="Comment">-- f : (X : Type) → (Bool ≡ X) → C</a>
<a id="435" class="Comment">-- f Bool refl = c</a>
<a id="454" class="Comment">-- こんな感じで path induction で関数 f を定義したとき、</a>
<a id="494" class="Comment">-- f Bool flippath はこれ以上簡約できない。</a>

<a id="527" class="Comment">-- ZFC だと {1} と {2} は等しいとは言えない。</a>

<a id="560" class="Comment">-- material な集合論と structural な集合論</a>

<a id="595" class="Comment">-- tt : S</a>

<a id="606" class="Comment">-- ff : S&#39;</a>

<a id="618" class="Comment">-- F : Type → Type であって ¬ (F S ≡ F S&#39;) となるものは作れない</a>
<a id="668" class="Comment">-- S ≡ S&#39; は MLTT だと言えないが、</a>
<a id="694" class="Comment">-- (Bool ≃ Bool) ≃ Bool が言える</a>

<a id="724" class="Comment">-- G , H : Grp で G ≃ H のとき、</a>
<a id="752" class="Comment">-- P : Grp → Type に対して、 P G ならば P H か？</a>
<a id="791" class="Comment">-- univalence があれば、言える (structure identity principle (SIP))</a>


<a id="¬flippath≡refl"></a><a id="853" href="0909-univalence-examples.html#853" class="Function">¬flippath≡refl</a> <a id="868" class="Symbol">:</a> <a id="870" href="0811-inductive-types.html#772" class="Function">¬</a> <a id="872" class="Symbol">(</a><a id="873" href="0909-univalence-examples.html#340" class="Function">flippath</a> <a id="882" href="0811-inductive-types.html#983" class="Datatype Operator">≡</a> <a id="884" href="0811-inductive-types.html#1029" class="InductiveConstructor">refl</a><a id="888" class="Symbol">)</a>
<a id="890" href="0909-univalence-examples.html#853" class="Function">¬flippath≡refl</a> <a id="905" href="0909-univalence-examples.html#905" class="Bound">flippath≡refl</a> <a id="919" class="Symbol">=</a> <a id="921" href="0909-univalence-examples.html#112" class="Function">¬tt≡ff</a> <a id="928" href="0909-univalence-examples.html#944" class="Function">lemma</a>
  <a id="936" class="Keyword">where</a>
  <a id="944" href="0909-univalence-examples.html#944" class="Function">lemma</a> <a id="950" class="Symbol">:</a> <a id="952" href="0811-inductive-types.html#840" class="InductiveConstructor">tt</a> <a id="955" href="0811-inductive-types.html#983" class="Datatype Operator">≡</a> <a id="957" href="0811-inductive-types.html#843" class="InductiveConstructor">ff</a>
  <a id="962" href="0909-univalence-examples.html#944" class="Function">lemma</a> <a id="968" class="Symbol">=</a>
    <a id="974" href="0811-inductive-types.html#840" class="InductiveConstructor">tt</a>                       <a id="999" href="0909-prelude.html#1612" class="Function Operator">≡⟨</a> <a id="1002" href="0909-prelude.html#594" class="Function">!</a> <a id="1004" class="Symbol">(</a><a id="1005" href="0909-prelude.html#3478" class="Function">uaβ</a> <a id="1009" href="0909-univalence-examples.html#144" class="Function">flip</a> <a id="1014" href="0909-univalence-examples.html#263" class="Function">flip-eqv</a> <a id="1023" href="0811-inductive-types.html#843" class="InductiveConstructor">ff</a><a id="1025" class="Symbol">)</a> <a id="1027" href="0909-prelude.html#1612" class="Function Operator">⟩</a>
    <a id="1033" href="0909-prelude.html#1166" class="Function">transport</a> <a id="1043" href="0909-prelude.html#384" class="Function">id</a> <a id="1046" href="0909-univalence-examples.html#340" class="Function">flippath</a> <a id="1055" href="0811-inductive-types.html#843" class="InductiveConstructor">ff</a> <a id="1058" href="0909-prelude.html#1612" class="Function Operator">≡⟨</a> <a id="1061" href="0909-prelude.html#1101" class="Function">ap</a> <a id="1064" class="Symbol">(λ</a> <a id="1067" href="0909-univalence-examples.html#1067" class="Bound">p</a> <a id="1069" class="Symbol">→</a> <a id="1071" href="0909-prelude.html#1166" class="Function">transport</a> <a id="1081" href="0909-prelude.html#384" class="Function">id</a> <a id="1084" href="0909-univalence-examples.html#1067" class="Bound">p</a> <a id="1086" href="0811-inductive-types.html#843" class="InductiveConstructor">ff</a> <a id="1089" class="Symbol">)</a> <a id="1091" href="0909-univalence-examples.html#905" class="Bound">flippath≡refl</a> <a id="1105" href="0909-prelude.html#1612" class="Function Operator">⟩</a>
    <a id="1111" href="0909-prelude.html#1166" class="Function">transport</a> <a id="1121" href="0909-prelude.html#384" class="Function">id</a> <a id="1124" href="0811-inductive-types.html#1029" class="InductiveConstructor">refl</a> <a id="1129" href="0811-inductive-types.html#843" class="InductiveConstructor">ff</a>     <a id="1136" href="0909-prelude.html#1612" class="Function Operator">≡⟨</a> <a id="1139" href="0811-inductive-types.html#1029" class="InductiveConstructor">refl</a> <a id="1144" href="0909-prelude.html#1612" class="Function Operator">⟩</a>
    <a id="1150" href="0811-inductive-types.html#843" class="InductiveConstructor">ff</a> <a id="1153" href="0909-prelude.html#1717" class="Function Operator">∎</a>

<a id="1156" class="Comment">-- HoTT = MLTT + univalence + HIT</a>
<a id="1190" class="Comment">-- Cubical Type Theory (CTT) は MLTT の規則を改造したもの。</a>
  <a id="1240" class="Comment">-- univalence が公理なしで示せる。</a>
  <a id="1267" class="Comment">-- HIT を作る規則がある。</a>
  <a id="1286" class="Comment">-- 規則がちょっと複雑。</a>
<a id="1300" class="Comment">-- Higher Observational Type Theory (HOTT)</a>
  <a id="1345" class="Comment">-- cubical よりも自然？</a>
  <a id="1365" class="Comment">-- 未完成</a></pre></body></html>